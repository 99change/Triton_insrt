// ---- Probe Config ----
    // Register declaration
    .reg .u32 %tid_x, %tid_y, %tid_z;
    .reg .u32 %bid_x, %bid_y, %bid_z;
    .reg .u32 %bdim_x, %bdim_y, %bdim_z;
    .reg .u32 %gdim_x, %gdim_y, %gdim_z;

    .reg .u64 %bdim_xyz;
    .reg .u64 %bid_linear, %tid_linear, %global_tid;

    .reg .u64 %store_addr, %buffer_base;
    .reg .u64 %n_thread;
    .reg .u64 %tmp<3>;
    .reg .pred %is_first;

    // Load parameters
    ld.param.u64 %buffer_base, [KERNEL_NAME_param_PARAM];

    // Register load
    mov.u32 %tid_x, %tid.x;
    mov.u32 %tid_y, %tid.y;
    mov.u32 %tid_z, %tid.z;

    mov.u32 %bid_x, %ctaid.x;
    mov.u32 %bid_y, %ctaid.y;
    mov.u32 %bid_z, %ctaid.z;

    mov.u32 %bdim_x, %ntid.x;
    mov.u32 %bdim_y, %ntid.y;
    mov.u32 %bdim_z, %ntid.z;

    mov.u32 %gdim_x, %nctaid.x;
    mov.u32 %gdim_y, %nctaid.y;
    mov.u32 %gdim_z, %nctaid.z;

    // NOTE: Compute the entire block size using x, y, and z dimensions since y and
    // z may be larger than 1.
    mul.wide.u32 %bdim_xyz, %bdim_y, %bdim_x;
    cvt.u64.u32 %tmp0, %bdim_z;
    mul.lo.u64 %bdim_xyz, %bdim_xyz, %tmp0;

    // Flatten the block index:
    //   bid_linear = ((bid_z * gdim_y + bid_y) * gdim_x + bid_x)
    mul.wide.u32 %tmp0, %bid_z, %gdim_y;  // bid_z * gdim_y
    cvt.u64.u32 %tmp2, %bid_y;
    add.u64 %tmp0, %tmp0, %tmp2;          // + bid_y
    cvt.u64.u32 %tmp1, %gdim_x;
    mul.lo.u64 %tmp1, %tmp0, %tmp1;       // * gdim_x
    cvt.u64.u32 %tmp2, %bid_x;
    add.u64 %bid_linear, %tmp1, %tmp2;    // + bid_x

    // Flatten the thread index:
    //   tid_linear = ((tid_z * bdim_y + tid_y) * bdim_x + tid_x)
    mul.wide.u32 %tmp0, %tid_z, %bdim_y;  // tid_z * bdim_y
    cvt.u64.u32 %tmp2, %tid_y;
    add.u64 %tmp0, %tmp0, %tmp2;          // + tid_y
    cvt.u64.u32 %tmp1, %bdim_x;
    mul.lo.u64 %tmp1, %tmp0, %tmp1;       // * bdim_x
    cvt.u64.u32 %tmp2, %tid_x;
    add.u64 %tid_linear, %tmp1, %tmp2;    // + tid_x

    // Flatten the global thread index:
    //   global_tid = bid_linear * (bdim_x * bdim_y * bdim_z) + tid_linear
    mul.lo.u64 %global_tid, %bid_linear, %bdim_xyz;
    add.u64 %global_tid, %global_tid, %tid_linear;

    mul.wide.u32 %n_thread, %gdim_x, %gdim_y;
    cvt.u64.u32 %tmp0, %gdim_z;
    mul.lo.u64 %n_thread, %n_thread, %tmp0;
    mul.lo.u64 %n_thread, %n_thread, %bdim_xyz;

    setp.eq.u64 %is_first, %global_tid, 0;
    @!%is_first bra $JUMP_CONFIG_PROBE;

    cvt.u64.u32 %tmp0, %bdim_x;
    cvt.u64.u32 %tmp1, %bdim_y;
    cvt.u64.u32 %tmp2, %bdim_z;
    
    mov.u64 %store_addr, %buffer_base;
    st.global.u64 [%store_addr], %tmp0;
    add.u64 %store_addr, %store_addr, 8;
    st.global.u64 [%store_addr], %tmp1;
    add.u64 %store_addr, %store_addr, 8;
    st.global.u64 [%store_addr], %tmp2;

    cvt.u64.u32 %tmp0, %gdim_x;
    cvt.u64.u32 %tmp1, %gdim_y;
    cvt.u64.u32 %tmp2, %gdim_z;
    
    add.u64 %store_addr, %store_addr, 8;
    st.global.u64 [%store_addr], %tmp0;
    add.u64 %store_addr, %store_addr, 8;
    st.global.u64 [%store_addr], %tmp1;
    add.u64 %store_addr, %store_addr, 8;
    st.global.u64 [%store_addr], %tmp2;
    add.u64 %store_addr, %store_addr, 8;
    st.global.u64 [%store_addr], %n_thread;

$JUMP_CONFIG_PROBE:
// ---- Probe Config ----